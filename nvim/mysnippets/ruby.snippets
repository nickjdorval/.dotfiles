snippet    attr
abbr        attr_reader
options     head
  attr_reader :${0:TARGET}

snippet    attr_accessor
abbr        attr_accessor
options     head
  attr_accessor :${0:TARGET}

snippet bye
abbr byebug
options head
  require 'byebug'; byebug

snippet pry
abbr pry
options head
  require 'pry'; binding.pry

snippet req
abbr require ''
options head
	require '${0}'

snippet reqr
abbr require_relative ''
options head
	require_relative '${0}'

snippet prot
abbr protected
options head
	protected

	${0}

snippet priv
abbr private
options head
	private

	${0}

snippet am
abbr alias_method :${1:new_name}, :${0:old_name}
options head
	alias_method :${1:new_name}, :${0:old_name}

snippet if
abbr  if...end
options head
  if ${1:true_condition}
    ${2}
  end

snippet ife
abbr  if...else
options head
  if ${1:true_condition}
    ${2}
  else
    ${3}
  end

snippet clap
abbr  class < parent..initialize..end
options head
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < ${2:ParentClass}
		def initialize(${3:args})
			${0}
		end
	end

snippet clai
abbr  class .. initialize .. end
options head
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		def initialize(${2:args})
			${0}
		end
	end

snippet module
abbr module...end
options head
  module ${1:`substitute(expand('%:t:r:r:r'), '\v%(^(.)|_(.))', '\u\1\u\2', 'g')`}
    ${0}
  end

snippet defi
abbr def..initialize..end
options head
	def initialize(${1:args})
		${0}
	end

snippet filee
abbr File.foreach() { |line| .. }
options head
	File.foreach(${1:'path/to/file'}) { |${2:line}| ${0} }

snippet filer
abbr File.read()
options head
	File.read(${1:'path/to/file'})

snippet Dirg
abbr Dir.global() { |file| .. }
options head
	Dir.glob(${1:'dir/glob/*'}) { |${2:file}| ${0} }

snippet Dir
abbr Dir[".."]
options head
	Dir[${1:'glob/**/*.rb'}]

snippet all
abbr all?
options word
	all? { |${1:e}| ${0} }

snippet alld
abbr all? do..end
options word
	all? do |${1:e}|
    ${0}
  end

snippet any
abbr any?
options word
	any? { |${1:e}| ${0} }

snippet anyd
abbr any? do..end
options word
	any? do |${1:e}|
    ${0}
  end

snippet eachwd
abbr each_with_object do..end
options word
	each_with_object(${1:memo}) do |${3:variable}, ${2:memo}|
  ${4:TARGET}
  end

snippet eachw
abbr each_with_object{}
options word
	each_with_object(${1:memo}) { |${3:variable}, ${2:memo}| ${4:TARGET} }

snippet fin
abbr find { }
options word
	find { |${1:e}| ${0} }

snippet find
abbr find do..end
options word
	find do |${1:e}|
		${0}
	end

snippet find_all
abbr find_all { }
options word
	find_all { |${1:e}| ${0} }

snippet finda
abbr find_all do..end
options word
	find_all do |${1:e}|
		${0}
	end

snippet mapd
abbr map do..end
options word
  map do |${1:variable}|
    ${2}
  end

snippet mapi
abbr map.with_index do..end
options word
  map.with_index do |${1:variable}, ${2:index} |
    ${0}
  end

snippet red
abbr reduce { }
options word
  reduce(${1:memo}) { |${2:memo}, ${3:variable}|  ${4:TARGET} }

snippet redd
abbr reduce do..end
options word
  reduce(${1:memo}) do |${2:memo}, ${3:variable}|
    ${4:TARGET}
  end

snippet sort
abbr sort do..end
options word
  sort do |${1:x}, ${2:y}|
    ${2}
  end

snippet sort_by
abbr sort_by do..end
options word
  sort_by do |${1:variable}|
    ${2}
  end

# # snippet "(\S+)\.each" "<elements>.each do |<element>| <block> end" r
# # `!p snip.rv=match.group(1)`.each { |${1:e}| $0 }
# # endsnippet

# # snippet "(\S+)\.red" "<array>.reduce(n) do |memo, var| <block> end" r
# # `!p snip.rv=match.group(1)`.reduce(${2:init}) do |${3:memo}, ${4:var}|
# # 	$0
# # end
# # endsnippet

# # snippet "(\S+)\.mapi" "<array>.map.with_index do |index, var| <block> end" r
# # `!p snip.rv=match.group(1)`.map.with_index do |index, ${2:var}|
# # 	$0
# # end
# # endsnippet

# # snippet "(\S+)\.map" "<array>.map do |var| <block> end" r
# # `!p snip.rv=match.group(1)`.map do | ${2:var}|
# # 	$0
# # end
# # endsnippet

# # ##########################
# # #     Minitest snippets     #
# # ##########################
snippet clast
abbr class test < Minitest::Test
options head
	class ${1:`substitute(expand('%:t:r:r:r'), '\v%(^(.)|_(.))', '\u\1\u\2', 'g')`} < Minitest::Test
		${0:TARGET}
	end

snippet deft
abbr def test
options head
  def test_${1:TEST_CASE}
    ${0:TARGET}
  end

snippet as
	assert ${1:test}, '${2:Failure message.}'
snippet ase
	assert_equal ${1:expected}, ${2:actual}
snippet asne
	assert_not_equal ${1:unexpected}, ${2:actual}
snippet asid
	assert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:2**-20}
snippet asi
	assert_includes ${1:collection}, ${2:object}
snippet asio
	assert_instance_of ${1:ExpectedClass}, ${2:actual_instance}
snippet asko
	assert_kind_of ${1:ExpectedKind}, ${2:actual_instance}
snippet asn
	assert_nil ${1:instance}
snippet asnn
	assert_not_nil ${1:instance}
snippet asm
	assert_match(/${1:expected_pattern}/, ${2:actual_string})
snippet asnm
	assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})
snippet aso
	assert_operator ${1:left}, :${2:operator}, ${3:right}
snippet asr
	assert_raise ${1:Exception} { ${0} }
snippet asrd
	assert_raise ${1:Exception} do
		${0}
	end
snippet asnr
	assert_nothing_raised ${1:Exception} { ${0} }
snippet asnrd
	assert_nothing_raised ${1:Exception} do
		${0}
	end
snippet asrt
	assert_respond_to ${1:object}, :${2:method}
snippet ass assert_same(..)
	assert_same ${1:expected}, ${2:actual}
snippet ass assert_send(..)
	assert_send [${1:object}, :${2:message}, ${3:args}]
snippet asns
	assert_not_same ${1:unexpected}, ${2:actual}
snippet ast
	assert_throws :${1:expected}, -> { ${0} }
snippet astd
	assert_throws :${1:expected} do
		${0}
	end
snippet asnt
	assert_nothing_thrown { ${0} }
snippet asntd
	assert_nothing_thrown do
		${0}
	end
snippet mb
	must_be ${0}
snippet wb
	wont_be ${0}
snippet mbe
	must_be_empty
snippet wbe
	wont_be_empty
snippet mbio
	must_be_instance_of ${0:Class}
snippet wbio
	wont_be_instance_of ${0:Class}
snippet mbko
	must_be_kind_of ${0:Class}
snippet wbko
	wont_be_kind_of ${0:Class}
snippet mbn
	must_be_nil
snippet wbn
	wont_be_nil
snippet mbsa
	must_be_same_as ${0:other}
snippet wbsa
	wont_be_same_as ${0:other}
snippet mbsi
	-> { ${0} }.must_be_silent
snippet mbwd
	must_be_within_delta ${1:0.1}, ${2:0.1}
snippet wbwd
	wont_be_within_delta ${1:0.1}, ${2:0.1}
snippet mbwe
	must_be_within_epsilon ${1:0.1}, ${2:0.1}
snippet wbwe
	wont_be_within_epsilon ${1:0.1}, ${2:0.1}
snippet me
	must_equal ${0:other}
snippet we
	wont_equal ${0:other}
snippet mi
	must_include ${0:what}
snippet wi
	wont_include ${0:what}
snippet mm
	must_match /${0:regex}/
snippet wm
	wont_match /${0:regex}/
snippet mout
	-> { ${1} }.must_output '${0}'
snippet mra
	-> { ${1} }.must_raise ${0:Exception}
snippet mrt
	must_respond_to :${0:method}
snippet wrt
	wont_respond_to :${0:method}
snippet msend
	must_send [ ${1:what}, :${2:method}, ${3:args} ]
snippet mthrow
	-> { throw :${1:error} }.must_throw :${2:error}
# # ##########################
# # #     Rspec snippets     #
# # ##########################
snippet let
abbr let(:${1:object}) { ${0} }
options head
	let(:${1:object}) { ${0} }

snippet let!
abbr let!(:${1:object}) { ${0} }
options head
	let!(:${1:object}) { ${0} }

snippet bef
abbr before {}
options head
	before { ${0:TARGET} }

snippet befd
abbr before do..end
options head
	before do
		${0:TARGET}
	end

snippet sav
abbr save_and_open_page
options head
  save_and_open_page

snippet get
abbr get ''
options head
	get '${1:path}'

snippet cont
abbr context
options head
	context '${1:context}' do
		${0:TARGET}
	end

snippet feat
abbr feature
options head
	feature '${1:feature}' do
		${0:TARGET}
	end

snippet descm
abbr describe
options head
	describe '${1:#method}' do
		${0:pending 'Not implemented'}
	end

snippet itd
abbr it...do
options head
	it '${1:behavior}' do
		${0:pending 'Not implemented'}
	end
snippet scen
abbr scenario
options head
	scenario '${1:scenario}' do
		${0:TARGET}
	end

snippet exp
abbr expect(${1:object}).to ${0}
options head
	expect(${1:object}).to ${0}

snippet iiexp
abbr it { is_expected.to ${0} }
options head
	it { is_expected.to ${0} }

snippet iiexpn
abbr it { is_expected.not_to ${0} }
options head
	it { is_expected.not_to ${0} }

snippet is
abbr it { should ${0} }
options head
	it { should ${0} }

snippet isn
abbr it { should_not ${0} }
options head
	it { should_not ${0} }
